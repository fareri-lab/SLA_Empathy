install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
install.packages("lmerTest")
install.packages("bayestestR")
install.packages("sjPlot")
install.packages("ggplot2")
rm(list = ls());
library(lme4);
plotPTdata <- function(gains,losses,certain,choices,titletxt){
color = array(dim=length(choices));
color[choices==1] = 'green';
color[choices==0] = 'red';
goInd = certain > 0;
mvInd = certain == 0;
par(mfrow=c(1,2))
plot(gains[mvInd],losses[mvInd],col=color[mvInd],main=titletxt)
plot(gains[goInd],certain[goInd],col=color[goInd],main=titletxt)
}
setwd(getwd());
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
getwd()
setwd("Users/farerilab/Documents/GitHub/SLA_Empathy/filtered");
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
setwd("/Users/farerilab/Documents/GitHub/SLA_Empathy/filtered");
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
d = d[is.finite(d$RT),]; # Dropping trials without RTs
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
ls(d)
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
ls(d)
nS = length(unique(d$Subject));
subjID = unique(d$Subject);
nCond = length(unique(d$Condition)); #need to change this to Condition (self, friend, stranger)
subjPartner = matrix(nrow = nS,ncol = 1);
for (s in 1:nS){
subjPartner[s] = unique(d$Condition[d$Subject==s])
}
nS
subjID
nCond
subjPartner
s
unique(d$Condition)
unique(d$Condition[d$Subject])
unique(d$Condition[d$Subject==s])
unique(d$Condition[d$Subject==1])
nS = length(unique(d$Subject));
subjID = unique(d$Subject);
nCond = length(unique(d$Condition)); #need to change this to Condition (self, friend, stranger)
subjPartner = matrix(nrow = nS,ncol = 1);
for (s in 1:nS){
subjPartner[s] = unique(d$Condition[d$Subject==s])
}
subjPartner[s]
rm(list = ls());
library(lme4);
##FOR EMPATHY DATA
#Subject: subj id
#Partner: 0 = self, 1 = stranger, -1 = friend
#SNS: 0 = self, 1 = social
#Sub 158 exclude from analyses because of excess number of missed trials.
plotPTdata <- function(gains,losses,certain,choices,titletxt){
color = array(dim=length(choices));
color[choices==1] = 'green';
color[choices==0] = 'red';
goInd = certain > 0;
mvInd = certain == 0;
par(mfrow=c(1,2))
plot(gains[mvInd],losses[mvInd],col=color[mvInd],main=titletxt)
plot(gains[goInd],certain[goInd],col=color[goInd],main=titletxt)
}
#wd = '~/Documents/Dropbox/Libraries/R_lib/SLA/';
setwd("/Users/farerilab/Documents/GitHub/SLA_Empathy/filtered");
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
d = d[is.finite(d$RT),]; # Dropping trials without RTs
nS = length(unique(d$Subject));
subjID = unique(d$Subject);
nCond = length(unique(d$Condition)); #need to change this to Condition (self, friend, stranger)
subjPartner = matrix(nrow = nS,ncol = 1);
unique(d$Subject)
rm(list = ls());
library(lme4);
##FOR EMPATHY DATA
#Subject: subj id
#Partner: 0 = self, 1 = stranger, -1 = friend
#SNS: 0 = self, 1 = social
#Sub 158 exclude from analyses because of excess number of missed trials.
plotPTdata <- function(gains,losses,certain,choices,titletxt){
color = array(dim=length(choices));
color[choices==1] = 'green';
color[choices==0] = 'red';
goInd = certain > 0;
mvInd = certain == 0;
par(mfrow=c(1,2))
plot(gains[mvInd],losses[mvInd],col=color[mvInd],main=titletxt)
plot(gains[goInd],certain[goInd],col=color[goInd],main=titletxt)
}
#wd = '~/Documents/Dropbox/Libraries/R_lib/SLA/';
setwd("/Users/farerilab/Documents/GitHub/SLA_Empathy/filtered");
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
d = d[is.finite(d$RT),]; # Dropping trials without RTs
nS = length(unique(d$Subject));
subjID = unique(d$Subject);
nCond = length(unique(d$Condition)); #need to change this to Condition (self, friend, stranger)
rm(list = ls());
library(lme4);
##FOR EMPATHY DATA
#Subject: subj id
#Partner: 0 = self, 1 = stranger, -1 = friend
#SNS: 0 = self, 1 = social
#Sub 158 exclude from analyses because of excess number of missed trials.
plotPTdata <- function(gains,losses,certain,choices,titletxt){
color = array(dim=length(choices));
color[choices==1] = 'green';
color[choices==0] = 'red';
goInd = certain > 0;
mvInd = certain == 0;
par(mfrow=c(1,2))
plot(gains[mvInd],losses[mvInd],col=color[mvInd],main=titletxt)
plot(gains[goInd],certain[goInd],col=color[goInd],main=titletxt)
}
#wd = '~/Documents/Dropbox/Libraries/R_lib/SLA/';
setwd("/Users/farerilab/Documents/GitHub/SLA_Empathy/filtered");
d = read.csv('SLA_Empathy_allsubs_Final_03_31_DF.csv');
d = d[is.finite(d$RT),]; # Dropping trials without RTs
nS = length(unique(d$Subject));
subjID = unique(d$Subject);
nCond = length(unique(d$Condition)); #need to change this to Condi
subjPartner = matrix(nrow = nS,ncol = 1);
for (s in 1:nS){
subjPartner[s] = unique(d$Condition[d$Subject==s])
}
warnings()
subjPartner
nTtoofast = array(data=NA,dim=c(nS,nCond));
for(s in 1:nS){
for(cnd in 1:nCond){
nTtoofast[s,cnd] = sum(d$RT[d$Subject==s & d$Condition==(cnd-1)]<200); # see gamble for 2s; then question mark. NBD.
}
}
nParams = 3; # rho, lambda, mu
est_independent = array(data = NA, dim = c(nParams*2+4,nS,nCond));
# varnames = c('rho','lambda','mu','R.se','L.se','M.se','nLL','lrt','lrtp','pctpred')
# est_independent <- as.data.frame(est_independent)
# colnames(est_independent) = varnames
convergence = array(data = NA, dim = c(nS,nCond));
niter = 500;
fit1 = glmer(Response ~ 1 + Amount1 + Amount2 + Certain + (0 + Amount1 + Amount2 + Certain | Subject),data=d,family='binomial')
summary(fit1)
fit3 = glmer(Response ~ 1 + Amount1 + Amount2 + Certain + SNS + Condition +
(0 + Amount1 + Amount2 + Certain | Subject),data=d,family='binomial',
control = glmerControl(optCtrl=list(maxfun=100000)));
summary(fit3)
library(sjPlot)
plot_model(fit3,type = int)
plot_model(fit3,type = c(int))
plot_model(fit3,type = "int")
plot_model(fit3,type = "pred")
library(rstan)
library(parallel)
d3 <- d[is.finite(d$Response),] # Subset out only the trials w/ responses
d3<-d3[d3$Include!==0]
d3<-d3[d3$Include!=0]
d3$Subject[d3$Include==0]
d3$SubName[d3$Include==0]
d3<-d3[d3$Subject!=6]
d3Subject!=6
d3$Subject!=6
d3<-d3$Subject!=6
d3 <- d[is.finite(d$Response),] # Subset out only the trials w/ responses
d3<-d3[!(d3$Include==0),]
unique(d3$SubName)
unique(d3$Subject)
length(unique(d3$Subject))
mean(d$Response[d$Subject==158])
mean(d$Response[d$Subject==158],na.rm=TRUE)
dataList <- list(
choices = d3$Response ,
gam1 = d3$Amount1 ,
gam2 = d3$Amount2 ,
cert = d3$Certain ,
ind = d3$Subject ,
selfother = d3$SNS ,
#partdiff = d$PartnerRecode ,
conddiff = d3$Condition,
nsubj = length(unique(d3$Subject)) ,
N = length(d3$Response)
)
stanmodel = 'sla_empathy_01_basic.stan'
nChains = 4
fitSteps = 5000 # Stan will save half this many x nChains per parameter
pars = c('meanLambda','meanRho','meanMu',
'sdLambda','sdRho','sdMu',
'rselfother','lselfother','mselfother',
'rconddiff','lconddiff','mconddiff',
'l','r','m'); # Not including all the rtmp, ltmp, and mtmp "parameters"
#'rpartdiff','lpartdiff','mpartdiff',
##### Fit the Model #####
starttime = proc.time()[3];
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
fit0 <- stan(file = stanmodel, data = dataList,
iter = 1, chains = 1, pars=pars) #, init=init1)
fit0time = proc.time()[3];
print(noquote(sprintf('Compilation time = %.1f seconds',(fit0time-starttime))))
##### Parallel Model Fit #####
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
sflist1 <-
mclapply(1:nChains, mc.cores = nChains,
function(i) stan(fit = fit0, seed=seed, data = dataList,
iter = fitSteps, chains = 1, chain_id = i,
pars = pars))
fittime = proc.time()[3];
print(noquote(sprintf('Sampling time = %.1f minutes.',(fittime-fit0time)/60)))
sflistFinal = list();
k = 1;
for (i in 1:nChains){
if (any(dim(sflist1[[i]]) > 0)) {
sflistFinal[[k]] <- sflist1[[i]]
k = k + 1;
}
else {print(noquote(sprintf('WARNING: Chain %d did not include any samples.',i)))}
}
save(stanmodel,sflistFinal,
file=sprintf('slaEmpathy_01_basic_%s.Rdata',format(Sys.Date(), format="%Y%m%d")))
fit1 <- sflist2stanfit(sflistFinal)
sSamples <- extract(fit1)
q95 <- c(0.025,0.975);q90 <- c(0.05,0.95);q85 <- c(0.075,0.925);q80 <- c(0.1,0.9);q75 <- c(0.125,0.875);q70 <- c(0.15,0.85)
print(fit1)
nChains = 4
fitSteps = 5000 # Stan will save half this many x nChains per parameter
pars = c('meanLambda','meanRho','meanMu',
'sdLambda','sdRho','sdMu',
'rselfother','lselfother','mselfother',
'rconddiff','lconddiff','mconddiff',
'l','r','m'); # Not including all the rtmp, ltmp, and mtmp "parameters"
starttime = proc.time()[3];
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
fit0 <- stan(file = stanmodel, data = dataList,
iter = 1, chains = 1, pars=pars) #, init=init1)
fit0time = proc.time()[3];
print(noquote(sprintf('Compilation time = %.1f seconds',(fit0time-starttime))))
##### Parallel Model Fit #####
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
sflist1 <-
mclapply(1:nChains, mc.cores = nChains,
function(i) stan(fit = fit0, seed=seed, data = dataList,
iter = fitSteps, chains = 1, chain_id = i,
pars = pars))
fittime = proc.time()[3];
print(noquote(sprintf('Sampling time = %.1f minutes.',(fittime-fit0time)/60)))
sflistFinal = list();
k = 1;
for (i in 1:nChains){
if (any(dim(sflist1[[i]]) > 0)) {
sflistFinal[[k]] <- sflist1[[i]]
k = k + 1;
}
else {print(noquote(sprintf('WARNING: Chain %d did not include any samples.',i)))}
}
save(stanmodel,sflistFinal,
file=sprintf('slaEmpathy_01_basic_%s.Rdata',format(Sys.Date(), format="%Y%m%d")))
fit1 <- sflist2stanfit(sflistFinal)
library(rstan)
library(parallel)
# set_cppo('debug') # make debugging easier
# set_cppo('fast') # for best running speed
d3 <- d[is.finite(d$Response),] # Subset out only the trials w/ responses
#d3$selfother <- as.numeric(d3$Partner > 0); # 1 when someone else is involved, 0 when it's just you
#d3$PartnerRecode <- d3$Partner;
#d3$PartnerRecode[d3$PartnerRecode == 2] <- -1; # 0 when SELF; 1 when OTHER, -1 when BOTH
#d3$ConditionRecode <- (d3$Condition+1)*d3$selfother;
#d3$ConditionRecode[d3$ConditionRecode==2] <- -1; # 0 when SELF; 1 when stranger, -1 when friend
dataList <- list(
choices = d3$Response ,
gam1 = d3$Amount1 ,
gam2 = d3$Amount2 ,
cert = d3$Certain ,
ind = d3$Subject ,
selfother = d3$SNS ,
#partdiff = d$PartnerRecode ,
conddiff = d3$Condition,
nsubj = length(unique(d3$Subject)) ,
N = length(d3$Response)
)
stanmodel = 'sla_empathy_01_basic.stan'
nChains = 4
fitSteps = 5000 # Stan will save half this many x nChains per parameter
pars = c('meanLambda','meanRho','meanMu',
'sdLambda','sdRho','sdMu',
'rselfother','lselfother','mselfother',
'rconddiff','lconddiff','mconddiff',
'l','r','m'); # Not including all the rtmp, ltmp, and mtmp "parameters"
#'rpartdiff','lpartdiff','mpartdiff',
##### Fit the Model #####
starttime = proc.time()[3];
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
fit0 <- stan(file = stanmodel, data = dataList,
iter = 1, chains = 1, pars=pars) #, init=init1)
fit0time = proc.time()[3];
print(noquote(sprintf('Compilation time = %.1f seconds',(fit0time-starttime))))
##### Parallel Model Fit #####
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
sflist1 <-
mclapply(1:nChains, mc.cores = nChains,
function(i) stan(fit = fit0, seed=seed, data = dataList,
iter = fitSteps, chains = 1, chain_id = i,
pars = pars))
fittime = proc.time()[3];
print(noquote(sprintf('Sampling time = %.1f minutes.',(fittime-fit0time)/60)))
sflistFinal = list();
k = 1;
for (i in 1:nChains){
if (any(dim(sflist1[[i]]) > 0)) {
sflistFinal[[k]] <- sflist1[[i]]
k = k + 1;
}
else {print(noquote(sprintf('WARNING: Chain %d did not include any samples.',i)))}
}
save(stanmodel,sflistFinal,
file=sprintf('slaEmpathy_01_basic_%s.Rdata',format(Sys.Date(), format="%Y%m%d")))
getwd()
setwd("/Users/farerilab/Documents/GitHub/SLA_Empathy");
library(rstan)
library(parallel)
# set_cppo('debug') # make debugging easier
# set_cppo('fast') # for best running speed
d3 <- d[is.finite(d$Response),] # Subset out only the trials w/ responses
#d3$selfother <- as.numeric(d3$Partner > 0); # 1 when someone else is involved, 0 when it's just you
#d3$PartnerRecode <- d3$Partner;
#d3$PartnerRecode[d3$PartnerRecode == 2] <- -1; # 0 when SELF; 1 when OTHER, -1 when BOTH
#d3$ConditionRecode <- (d3$Condition+1)*d3$selfother;
#d3$ConditionRecode[d3$ConditionRecode==2] <- -1; # 0 when SELF; 1 when stranger, -1 when friend
dataList <- list(
choices = d3$Response ,
gam1 = d3$Amount1 ,
gam2 = d3$Amount2 ,
cert = d3$Certain ,
ind = d3$Subject ,
selfother = d3$SNS ,
#partdiff = d$PartnerRecode ,
conddiff = d3$Condition,
nsubj = length(unique(d3$Subject)) ,
N = length(d3$Response)
)
stanmodel = 'sla_empathy_01_basic.stan'
nChains = 4
fitSteps = 5000 # Stan will save half this many x nChains per parameter
pars = c('meanLambda','meanRho','meanMu',
'sdLambda','sdRho','sdMu',
'rselfother','lselfother','mselfother',
'rconddiff','lconddiff','mconddiff',
'l','r','m'); # Not including all the rtmp, ltmp, and mtmp "parameters"
#'rpartdiff','lpartdiff','mpartdiff',
##### Fit the Model #####
starttime = proc.time()[3];
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
fit0 <- stan(file = stanmodel, data = dataList,
iter = 1, chains = 1, pars=pars) #, init=init1)
fit0time = proc.time()[3];
print(noquote(sprintf('Compilation time = %.1f seconds',(fit0time-starttime))))
##### Parallel Model Fit #####
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
sflist1 <-
mclapply(1:nChains, mc.cores = nChains,
function(i) stan(fit = fit0, seed=seed, data = dataList,
iter = fitSteps, chains = 1, chain_id = i,
pars = pars))
fittime = proc.time()[3];
print(noquote(sprintf('Sampling time = %.1f minutes.',(fittime-fit0time)/60)))
sflistFinal = list();
k = 1;
for (i in 1:nChains){
if (any(dim(sflist1[[i]]) > 0)) {
sflistFinal[[k]] <- sflist1[[i]]
k = k + 1;
}
else {print(noquote(sprintf('WARNING: Chain %d did not include any samples.',i)))}
}
save(stanmodel,sflistFinal,
file=sprintf('slaEmpathy_01_basic_%s.Rdata',format(Sys.Date(), format="%Y%m%d")))
library(rstan)
library(parallel)
# set_cppo('debug') # make debugging easier
# set_cppo('fast') # for best running speed
d3 <- d[is.finite(d$Response),] # Subset out only the trials w/ responses
#d3$selfother <- as.numeric(d3$Partner > 0); # 1 when someone else is involved, 0 when it's just you
#d3$PartnerRecode <- d3$Partner;
#d3$PartnerRecode[d3$PartnerRecode == 2] <- -1; # 0 when SELF; 1 when OTHER, -1 when BOTH
#d3$ConditionRecode <- (d3$Condition+1)*d3$selfother;
#d3$ConditionRecode[d3$ConditionRecode==2] <- -1; # 0 when SELF; 1 when stranger, -1 when friend
dataList <- list(
choices = d3$Response ,
gam1 = d3$Amount1 ,
gam2 = d3$Amount2 ,
cert = d3$Certain ,
ind = d3$Subject ,
selfother = d3$SNS ,
#partdiff = d$PartnerRecode ,
conddiff = d3$Condition,
nsubj = length(unique(d3$Subject)) ,
N = length(d3$Response)
)
stanmodel = 'sla_empathy_01_basic.stan'
nChains = 4
fitSteps = 5000 # Stan will save half this many x nChains per parameter
pars = c('meanLambda','meanRho','meanMu',
'sdLambda','sdRho','sdMu',
'rselfother','lselfother','mselfother',
'rconddiff','lconddiff','mconddiff',
'l','r','m'); # Not including all the rtmp, ltmp, and mtmp "parameters"
#'rpartdiff','lpartdiff','mpartdiff',
##### Fit the Model #####
starttime = proc.time()[3];
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
fit0 <- stan(file = stanmodel, data = dataList,
iter = 1, chains = 1, pars=pars) #, init=init1)
fit0time = proc.time()[3];
print(noquote(sprintf('Compilation time = %.1f seconds',(fit0time-starttime))))
##### Parallel Model Fit #####
# seed <- 123; # for a reproducible fit
seed <- runif(1,1,1e6); # Stan wants a random integer from 1 to max supportable
sflist1 <-
mclapply(1:nChains, mc.cores = nChains,
function(i) stan(fit = fit0, seed=seed, data = dataList,
iter = fitSteps, chains = 1, chain_id = i,
pars = pars))
fittime = proc.time()[3];
print(noquote(sprintf('Sampling time = %.1f minutes.',(fittime-fit0time)/60)))
sflistFinal = list();
k = 1;
for (i in 1:nChains){
if (any(dim(sflist1[[i]]) > 0)) {
sflistFinal[[k]] <- sflist1[[i]]
k = k + 1;
}
else {print(noquote(sprintf('WARNING: Chain %d did not include any samples.',i)))}
}
save(stanmodel,sflistFinal,
file=sprintf('slaEmpathy_01_basic_%s.Rdata',format(Sys.Date(), format="%Y%m%d")))
pairs(plot)
fit1
plot(fit1)
sflist1
plot(sflist1)
plot(sflistFinal)
sflistFinal
plot(slaEmpathy_01_basic)
plot(sflist1,type="trace")
traceplot(fit1)
traceplot(fit0)
fit1 <- sflist2stanfit(sflistFinal)
traceplot(fit1)
par(mfrow=c(1,1))
traceplot(fit1)
summary(fit3)
plot_model(fit3,type=c("pred"))
mean(d3$Response[d3$SNS==0])
mean(d3$Response[d3$SNS==1])
mean(d3$Response[d3$Condition==-1])
mean(d3$Response[d3$Condition==0])
mean(d3$Response[d3$Condition==1])
sflistFinal
traceplot(fit1,"meanLambda")
save.image("~/Documents/GitHub/SLA_Empathy/stan_model_4_6_21.RData")
